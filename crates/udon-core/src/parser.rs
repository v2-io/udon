//! UDON Parser - Generated by genmachine
//!
//! This is a generated file. Do not edit directly.
//! Source: bootstrap.machine

use crate::event::Event;
use crate::span::Span;

/// Parser state for streaming UDON parsing.
///
/// The lifetime `'a` refers to the source buffer - all parsed content
/// is zero-copy slices into the original input.
pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    line: u32,
    column: u32,
    line_start: usize,

    /// Accumulator start position (for MARK/TERM pattern)
    mark_start: usize,

    /// Pending events to return
    events: Vec<Event<'a>>,
}

impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    #[inline]
    pub fn new(input: &'a [u8]) -> Self {
        Self {
            input,
            pos: 0,
            line: 1,
            column: 1,
            line_start: 0,
            mark_start: 0,
            events: Vec::new(),
        }
    }

    /// Parse the entire input and return all events.
    pub fn parse(&mut self) -> Vec<Event<'a>> {
        self.parse_line();
        std::mem::take(&mut self.events)
    }

    /// Check if we've reached end of input.
    #[inline]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    /// Get current byte without advancing.
    #[inline]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

    /// Advance one byte (handles line/column tracking).
    #[inline]
    fn advance(&mut self) {
        if let Some(b) = self.input.get(self.pos) {
            if *b == b'\n' {
                self.line += 1;
                self.column = 1;
                self.pos += 1;
                self.line_start = self.pos;
            } else {
                self.column += 1;
                self.pos += 1;
            }
        }
    }

    /// Mark the current position for accumulation.
    #[inline]
    fn mark(&mut self) {
        self.mark_start = self.pos;
    }

    /// Get the accumulated slice from mark to current position.
    #[inline]
    fn term(&self) -> &'a [u8] {
        &self.input[self.mark_start..self.pos]
    }

    /// Create a span from mark to current position.
    #[inline]
    fn span_from_mark(&self) -> Span {
        Span::new(self.mark_start, self.pos)
    }

    /// Emit an event.
    #[inline]
    fn emit(&mut self, event: Event<'a>) {
        self.events.push(event);
    }

    // ========== Generated State Machine ==========


    fn parse_line(&mut self) {
        #[derive(Clone, Copy)]
        enum State { SMain, SComment, SText }

        let mut state = State::SMain;
        loop {
            if self.eof() {
                return;
            }

            match state {
                State::SMain => {
                    match self.peek().unwrap() {
                        b'\n' => {
                            self.advance();
                            state = State::SMain;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SText;
                        }
                    }
                }
                State::SComment => {
                    match self.peek().unwrap() {
                        b'\n' => {
                            self.emit(Event::Comment { content: self.term(), span: self.span_from_mark() });
                            state = State::SMain;
                        }
                        _ => {
                            self.advance();
                        }
                    }
                }
                State::SText => {
                    match self.peek().unwrap() {
                        b'\n' => {
                            self.emit(Event::Text { content: self.term(), span: self.span_from_mark() });
                            state = State::SMain;
                        }
                        b';' => {
                            self.emit(Event::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            self.mark();
                            state = State::SComment;
                        }
                        _ => {
                            self.advance();
                        }
                    }
                }
            }
        }
    }

}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_input() {
        let mut parser = Parser::new(b"");
        let events = parser.parse();
        assert!(events.is_empty());
    }

    #[test]
    fn test_comment() {
        let mut parser = Parser::new(b"; this is a comment\n");
        let events = parser.parse();
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0], Event::Comment { .. }));
    }

    #[test]
    fn test_text() {
        let mut parser = Parser::new(b"hello world\n");
        let events = parser.parse();
        assert_eq!(events.len(), 1);
        assert!(matches!(events[0], Event::Text { .. }));
    }
}
