; UDON Minimal Reference — "|" element, ":" attribute, ";" comment, "!" dynamic

; === CORE PATTERNS ===

|element[id].class :attr value
|element[id].class :attr value Content on same line
|element[id].class :attr value |child Child content here
|element
  |child
  Prose content with |{em inline elements} and !{{interpolation}}.

; Inline elements embed structure in prose:
|p Prose with |{em emphasis}, |{strong bold}, and |{a :href /doc links}.
|p Nested: |{strong This is |{em very} important}.
|p With attrs: |{a :href /x :title "Tooltip" click here}.
|p Inline comments: text ;{comment stripped or passed through} more text.

; Rightward nesting vs inline siblings:
|a |b |c                        ; a > b > c (nesting)
|a :x 1 |b :y 2 |c Content      ; nesting with attrs at each level
|div |{a Link} |{b Text} |{c More}  ; div > (a, b, c) (siblings)

; === ATTRIBUTES ===
; Type comes from syntax, not value-sniffing (no "Norway problem")

|config
  :string      "hello world"    ; string (quoted)
  :unquoted    simple-value     ; string (unquoted)
  :number      42               ; integer
  :float       3.14             ; float
  :bool        true             ; boolean (also: false)
  :null        nil              ; nil (also: null, ~)
  :flag                         ; true (no value = flag)
  :list        [one two three "with spaces"]
  :empty       []
  :mixed       [42 true "hi" nil]

  ; Structured attribute with children:
  :headers
    |header :name Content-Type :value application/json
  :inline-val  |{limit :requests 100 :window 60s}

; === ELEMENTS ===

; Element variations:
|element-name[optional-id].class1.class2
|[id-only]                           ; no element name
|empty                               ; empty element

; Class-only elements (mixins):
|.reusable :timeout 30
|.logging :level info
|service.reusable.logging :name mine ; multiple mixins

; Element suffixes become quoted attributes:
|functional?             ; == |functional :'?' true
|field?[opt]             ; suffix before id
|children[clist]+        ; == |children[clist] :'+' true

; === REFERENCES ===

|license[mit]
  MIT License text here...

|project
  :name "My Project"
  :license @[mit]               ; @[id] inserts full element

|.db-defaults[base]
  :adapter postgres
  :pool 5

|database :[base] :name mydb    ; :[id] merges attributes

; === DYNAMICS ===

|page :title !{{page.title}}

  ; Conditionals:
  !if user
    Welcome, !{{user.name | capitalize}}!
    !if user.admin
      |admin-panel
    !elif user.moderator
      |mod-panel
    !else
      |user-panel
  !else
    |login-prompt

  ; Iteration:
  !for post in posts
    |article :id post-!{{post.id}}
      |h2 !{{post.title}}
      |p !{{post.excerpt | truncate 200}}

  ; Local binding:
  !let featured = posts | where "featured" true | first
    |featured !{{featured.title}}

; Raw code blocks (not parsed as UDON):
!raw:elixir
  def hello do
    "world" |> String.upcase()  # This pipe is Elixir
  end

; Include other files:
!include partials/header

; === ESCAPING ===

; Apostrophe escapes the next character:
'|not-an-element — prose starting with pipe
':not-an-attribute — colon in text
';not-a-comment — semicolon in prose
''literal apostrophe

; Triple backtick for raw blocks:
|example
  Normal UDON here, then: ```
|this is literal, not an element
:this too
``` Back to UDON.
